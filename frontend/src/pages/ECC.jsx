import React, { useState } from "react";
import TextField from "@mui/material/TextField";
import Button from "@mui/material/Button";
import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import Paper from "@mui/material/Paper";
import Stack from "@mui/material/Stack";
import MathJax from "react-mathjax";
import { createTheme, ThemeProvider } from "@mui/material";

const theme = createTheme({
  typography: {
    fontFamily: ["Poppins", "Neue Helvetica Condensed BQ", "san-serif"].join(
      ","
    ),
  },
});

const ECC = () => {
  const hasseFormula = `
    p + 1 - 2\\sqrt{p} \\leq n \\leq p + 1 + 2\\sqrt{p}
  `;

  const [a, setA] = useState(null);
  const [b, setB] = useState(null);
  const [p, setP] = useState(null);
  const [generatorPointX, setGeneratorPointX] = useState(null);
  const [generatorPointY, setGeneratorPointY] = useState(null);

  const satistyHasseTheorem = false;

  const [s, setS] = useState(null);
  return (
    <ThemeProvider theme={theme}>
      <Stack spacing={2} sx={{ padding: 3 }}>
        <Typography variant="h4" gutterBottom>
          Elliptic Curve Cryptography
        </Typography>

        {/* Input Fields */}
        <Paper sx={{ padding: 3, marginBottom: 3 }}>
          {/* Elliptic curve parameters */}
          <Typography variant="h4" fontWeight="bold" gutterBottom>
            Step 1: Set up your elliptic curve parameters.
          </Typography>
          <Stack p={2} spacing={2}>
            <TextField
              label="a"
              fullWidth
              type="number"
              value={a ?? ""}
              onChange={(e) => setA(Number(e.target.value))}
            />
            <TextField
              label="b"
              fullWidth
              type="number"
              value={b ?? ""}
              onChange={(e) => setB(Number(e.target.value))}
            />
            <TextField
              label="p"
              fullWidth
              type="number"
              value={p ?? ""}
              onChange={(e) => setP(Number(e.target.value))}
            />
            <MathJax.Provider>
              <Typography>
                The order of the elliptic curve is the total number of points on
                the curve, including the point at infinity. It is typically
                chosen such that it satisfies the Hasse theorem, which bounds
                the order ùëõ n by:
              </Typography>
              <Typography variant="body1">
                <MathJax.Node formula={hasseFormula} />
              </Typography>
            </MathJax.Provider>
            <Typography>
              The order of the entired elliptic curve is:{" "}
              <strong>order n</strong>, which does{" "}
              {satistyHasseTheorem ? "" : "not"} satisfy the Hasse theorem.{" "}
              <strong>
                {satistyHasseTheorem
                  ? ""
                  : "Please choose different curve parameters."}
              </strong>
            </Typography>
          </Stack>

          {/* Generator point */}
          <Stack p={2} spacing={2}>
            <Typography variant="h4" fontWeight="bold" gutterBottom>
              Step 2: Choose a generator point.
            </Typography>
            <Typography component="p">
              For the elliptic curves over finite fields, the ECC cryptosystems
              define a special pre-defined (constant) EC point called generator
              point G (base point), which can generate any other point in its
              subgroup over the elliptic curve by multiplying G by some integer
              in the range [0...r].
            </Typography>
            <Typography>
              The number r is called "order" of the cyclic subgroup generated by
              G.{" "}
              <strong>
                The order of the generator point G should be a prime number
              </strong>
              .
            </Typography>
            <TextField
              label="Generator Point x"
              fullWidth
              type="number"
              value={generatorPointX ?? ""}
              onChange={(e) => setGeneratorPointX(e.target.value)}
            />
            <TextField
              label="Generator Point y"
              fullWidth
              type="number"
              value={generatorPointY ?? ""}
              onChange={(e) => setGeneratorPointY(e.target.value)}
            />
          </Stack>

          <Stack p={2} spacing={2}>
            <Typography variant="h4" fontWeight="bold" gutterBottom>
              Step 3: Choose a private key.
            </Typography>
            <Typography>
              The private key is a randomly chosen integer in the range [1,
              r-1].
            </Typography>
            <TextField
              label="Private key s"
              fullWidth
              type="number"
              value={s ?? ""}
              onChange={(e) => setS(e.target.value)}
            />

            <Button variant="contained">Generate Public Key</Button>
            <Typography>
              The public key is P = kG = <b>Point P</b>
            </Typography>
          </Stack>

          <Stack p={2} spacing={2}>
            <Typography variant="h4" fontWeight="bold" gutterBottom>
              Private Key, Public Key and the Generator Point in ECC
            </Typography>
            <Typography gutterBottom>
              After the abovementioned steps, in ECC we have:
              <ul>
                <li>
                  Elliptic curve parameters: (a, b, p) = ({a}, {b}, {p})
                </li>
                <li>
                  Generator point: G({generatorPointX}, {generatorPointY})
                </li>
                <li>Private key: {s}</li>
                <li>Public key P = sG</li>
              </ul>
            </Typography>
          </Stack>
        </Paper>

        {/* Buttons to trigger API calls */}
        {/* <Box sx={{ marginBottom: 3 }}>
        <Button
          variant="contained"
          onClick={handleFactorsRequest}
          sx={{ marginRight: 2 }}
        >
          Get Factors
        </Button>
        <Button
          variant="contained"
          onClick={handlePrimitiveRequest}
          sx={{ marginRight: 2 }}
        >
          Get Primitive Root
        </Button>
        <Button
          variant="contained"
          onClick={handleKeyGenerateRequest}
          sx={{ marginRight: 2 }}
        >
          Generate Keys
        </Button>
        <Button
          variant="contained"
          onClick={handleEncryptRequest}
          sx={{ marginRight: 2 }}
        >
          Encrypt
        </Button>
        <Button variant="contained" onClick={handleDecryptRequest}>
          Decrypt
        </Button>
      </Box> */}

        {/* Results */}
        {/* <Paper sx={{ padding: 3 }}>
        <Typography variant="h6" gutterBottom>
          Results
        </Typography>
        {factorsResult && (
          <Typography>
            <strong>Factors of {n}:</strong> {factorsResult.factors.join(", ")}
          </Typography>
        )}

        {primitiveResult && (
          <Typography>
            <strong>Primitive Root of {n}:</strong>{" "}
            {primitiveResult.primitive_root}
          </Typography>
        )}

        {keyResult && (
          <Typography>
            <strong>Private Key:</strong> {keyResult.private_key}
            <br />
            <strong>Public Key:</strong> {keyResult.public_key}
          </Typography>
        )}

        {encryptedResult && (
          <Typography>
            <strong>Encrypted Message:</strong>
            <br />
            Y1: {encryptedResult.y1}
            <br />
            Y2: {encryptedResult.y2}
          </Typography>
        )}

        {decryptedResult && (
          <Typography>
            <strong>Decrypted Message:</strong>{" "}
            {decryptedResult.decrypted_message}
          </Typography>
        )}
      </Paper> */}
      </Stack>
    </ThemeProvider>
  );
};

export default ECC;
